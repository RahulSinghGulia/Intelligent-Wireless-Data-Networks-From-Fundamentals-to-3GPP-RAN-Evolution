<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OFDM System Simulator & Tutorial</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Basic Styling (You'd expand this significantly for a full tutorial) */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8fafc;
            color: #334155;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        h1, h2, h3 {
            color: #1e293b;
            text-align: center;
            margin-bottom: 25px;
        }

        section {
            background-color: #fff;
            padding: 25px;
            margin-bottom: 30px;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-right: 20px;
        }

        .control-group label {
            margin-bottom: 5px;
            font-weight: bold;
            color: #475569;
        }

        input[type="range"] {
            width: 200px;
            margin-top: 5px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #0056b3;
        }

        .tab-buttons {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #e2e8f0;
        }

        .tab-button {
            background-color: #f0f4f8;
            color: #475569;
            border: none;
            padding: 12px 25px;
            cursor: pointer;
            font-size: 16px;
            border-radius: 8px 8px 0 0;
            transition: background-color 0.3s ease, color 0.3s ease;
            margin: 0 2px;
        }

        .tab-button.active {
            background-color: #007bff;
            color: white;
            border-bottom: 2px solid #007bff;
        }

        .tab-button:hover:not(.active) {
            background-color: #e2e8f0;
        }

        .tab-content {
            display: none;
            padding: 20px 0;
        }

        .tab-content.active {
            display: block;
        }

        .metrics {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding: 15px;
            background-color: #f0f4f8;
            border-radius: 6px;
        }

        .metric-item {
            text-align: center;
            font-size: 1.1em;
            color: #1e293b;
        }

        .metric-item strong {
            display: block;
            font-size: 1.4em;
            color: #007bff;
            margin-top: 5px;
        }

        /* High Contrast Mode */
        body.high-contrast {
            background-color: #000 !important;
            color: #fff !important;
        }
        body.high-contrast .container,
        body.high-contrast section {
            background-color: #111 !important;
            color: #fff !important;
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.2) !important;
        }
        body.high-contrast h1,
        body.high-contrast h2,
        body.high-contrast h3 {
            color: #00ff00 !important; /* Green for contrast */
        }
        body.high-contrast .tab-button {
            background-color: #333 !important;
            color: #eee !important;
        }
        body.high-contrast .tab-button.active {
            background-color: #00ff00 !important;
            color: #000 !important;
        }
        body.high-contrast button {
            background-color: #00ff00 !important;
            color: #000 !important;
            border: 1px solid #00ff00 !important;
        }
        body.high-contrast button:hover {
            background-color: #00aa00 !important;
        }
        body.high-contrast .control-group label {
            color: #00ff00 !important;
        }
        body.high-contrast .metrics {
            background-color: #333 !important;
        }
        body.high-contrast .metric-item strong {
            color: #00ff00 !important;
        }
        body.high-contrast input[type="range"] {
            -webkit-appearance: none;
            background: #555;
            height: 8px;
            border-radius: 5px;
        }
        body.high-contrast input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #00ff00;
            border-radius: 50%;
            cursor: pointer;
        }
        body.high-contrast input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ff00;
            border-radius: 50%;
            cursor: pointer;
        }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>OFDM System Interactive Tutorial</h1>
            <p style="text-align: center;">Explore the fundamentals and challenges of Orthogonal Frequency-Division Multiplexing.</p>
            <div class="section-header">
                <h2>Accessibility</h2>
                <button id="contrastToggle">Toggle High Contrast</button>
            </div>
        </header>

        <section id="introduction">
            <h2>1. What is OFDM?</h2>
            <p>Orthogonal Frequency-Division Multiplexing (OFDM) is a method of encoding digital data on multiple carrier frequencies. It's a key technology in modern wireless communication standards like Wi-Fi (802.11), 4G LTE, and 5G. OFDM divides a high-rate data stream into several lower-rate streams, which are then transmitted simultaneously over multiple subcarriers. This makes the system more robust to frequency-selective fading and inter-symbol interference (ISI).</p>
            <p>The core idea behind OFDM is to achieve orthogonality between subcarriers, meaning that the peak of one subcarrier's spectrum aligns with the nulls of all other subcarriers' spectra. This allows subcarriers to overlap without causing inter-carrier interference (ICI), leading to efficient spectrum utilization.</p>

            <h3>1.1 Subcarrier Visualization: FDM vs. OFDM</h3>
            <div class="controls">
                <button id="showTraditionalFdm">Traditional FDM</button>
                <button id="showOfdm">OFDM (Orthogonal)</button>
            </div>
            <div class="chart-container">
                <canvas id="subcarrierChart"></canvas>
            </div>
            <p>Observe how in Traditional FDM, subcarriers are separated by guard bands to prevent interference. In OFDM, subcarriers overlap, but their orthogonality ensures that they can still be uniquely decoded at the receiver.</p>
        </section>

        <section id="orthogonality">
            <h2>2. Key Principle: Orthogonality</h2>
            <p>Orthogonality in OFDM is achieved by precisely spacing the subcarrier frequencies such that at the sampling instant of the FFT/IFFT, each subcarrier has an integer number of cycles within the symbol duration, and all other subcarriers have zero amplitude. This means they do not interfere with each other despite spectral overlap.</p>
            <div class="controls">
                <button id="showSingleSubcarrier">Single Subcarrier</button>
                <button id="showMultipleSubcarriers">Multiple Orthogonal Subcarriers</button>
            </div>
            <div class="chart-container">
                <canvas id="orthogonalityChart"></canvas>
            </div>
            <p>The graph above shows the time-domain representation of subcarriers. When multiple subcarriers are orthogonal, they can be separated perfectly using the Fast Fourier Transform (FFT) at the receiver.</p>
        </section>

        <section id="cyclic-prefix">
            <h2>3. Mitigating ISI: The Cyclic Prefix (CP)</h2>
            <p>In wireless channels, signals can arrive at the receiver via multiple paths, leading to time dispersion (multipath delay spread). This can cause Inter-Symbol Interference (ISI) and Inter-Carrier Interference (ICI) if not properly handled.</p>
            <p>The Cyclic Prefix (CP) is a copy of the end portion of an OFDM symbol that is appended to the beginning of the symbol. It serves two main purposes:</p>
            <ol>
                <li>It acts as a **guard interval**, absorbing multipath delays and ensuring that the useful part of the OFDM symbol (after the CP is removed at the receiver) is free from ISI caused by the previous symbol.</li>
                <li>It converts the linear convolution of the signal with the channel into a **circular convolution**, which can be easily compensated for in the frequency domain using a simple one-tap equalizer for each subcarrier.</li>
            </ol>
            <div class="controls">
                <button id="showWithoutCp">Symbol Without CP</button>
                <button id="showWithCp">Symbol With CP</button>
            </div>
            <div class="chart-container">
                <canvas id="cyclicPrefixChart"></canvas>
            </div>
            <p>Observe how the CP effectively extends the symbol, providing a buffer against delayed versions of the signal arriving at the receiver.</p>
        </section>

        <section id="ofdm-system">
            <h2>4. OFDM System Overview</h2>
            <p>Here, you can simulate a simplified OFDM system and observe the effects of various parameters and noise.</p>
            <div class="controls">
                <div class="control-group">
                    <label for="numSubcarriers">Number of Subcarriers:</label>
                    <input type="range" id="numSubcarriers" min="8" max="64" value="16" step="8">
                    <span id="numSubcarriersValue">16 subcarriers</span>
                </div>
                <div class="control-group">
                    <label for="cpRatio">Cyclic Prefix Ratio:</label>
                    <input type="range" id="cpRatio" min="0" max="0.25" value="0.1" step="0.05">
                    <span id="cpRatioValue">10%</span>
                </div>
                <div class="control-group">
                    <label for="snr">Signal-to-Noise Ratio (SNR):</label>
                    <input type="range" id="snr" min="0" max="30" value="20" step="5">
                    <span id="snrValue">20 dB</span>
                </div>
                <button id="transmitBtn">Transmit Signal</button>
            </div>
            <div class="chart-container">
                <canvas id="ofdmSystemChart"></canvas>
            </div>
            <p>This chart shows the transmitted and received signals in the time domain, incorporating the effects of noise based on the SNR. Increasing SNR reduces noise and improves signal quality.</p>
        </section>

        <section id="challenges">
            <h2>5. OFDM Challenges and Impairments</h2>
            <div class="tab-buttons">
                <button class="tab-button active" data-tab="pap">PAPR</button>
                <button class="tab-button" data-tab="foffset">Frequency Offset</button>
                <button class="tab-button" data-tab="timing">Timing Offset</button>
                <button class="tab-button" data-tab="channel">Channel Estimation</button>
            </div>

            <div id="pap-tab" class="tab-content active">
                <h3>5.1 Peak-to-Average Power Ratio (PAPR)</h3>
                <p>OFDM signals, being a sum of many independent subcarriers, can exhibit a high Peak-to-Average Power Ratio (PAPR). This means the instantaneous power can be much higher than the average power. High PAPR is undesirable because it requires power amplifiers with high linearity, which are expensive and consume more power. This chart illustrates a signal with high PAPR.</p>
                <div class="chart-container">
                    <canvas id="paprChart"></canvas>
                </div>
                <p>The signal peaks significantly above its average power level, demonstrating the PAPR issue.</p>
            </div>

            <div id="foffset-tab" class="tab-content">
                <h3>5.2 Frequency Offset (FO)</h3>
                <p>Frequency offset, caused by mismatches between transmitter and receiver oscillators or Doppler shifts, leads to a loss of orthogonality between subcarriers. This results in Inter-Carrier Interference (ICI), where power from one subcarrier spills into adjacent ones, degrading performance.</p>
                <div class="chart-container">
                    <canvas id="foffsetChart"></canvas>
                </div>
                <p>Observe how a frequency offset causes the subcarrier spectra to shift, leading to overlap at non-null points for adjacent subcarriers.</p>
            </div>

            <div id="timing-tab" class="tab-content">
                <h3>5.3 Timing Offset (TO)</h3>
                <p>Accurate symbol synchronization (timing) is crucial in OFDM. A timing offset, where the receiver samples the OFDM symbol at the wrong time, can lead to both Inter-Symbol Interference (ISI) and Inter-Carrier Interference (ICI), especially if the sampling window extends beyond the cyclic prefix or into adjacent symbols.</p>
                <div class="chart-container">
                    <canvas id="timingChart"></canvas>
                </div>
                <p>This chart demonstrates how a shift in the reception window can distort the received symbol, leading to errors.</p>
            </div>

            <div id="channel-tab" class="tab-content">
                <h3>5.4 Channel Estimation and Equalization</h3>
                <p>Wireless channels introduce distortions (fading, multipath). To correctly decode the received signal, the receiver needs to estimate the channel's characteristics (Channel Frequency Response - CFR) and then apply an equalizer to compensate for these distortions. This chart shows a typical channel response and an estimated response.</p>
                <div class="chart-container">
                    <canvas id="channelChart"></canvas>
                </div>
                <p>The blue line represents the actual channel response, while the orange line represents the receiver's estimate. Accurate estimation is key for effective equalization.</p>
            </div>
        </section>

        <section id="simulation">
            <h2>6. End-to-End OFDM Simulation</h2>
            <p>Run a full simulation to see the effects of different modulation schemes, channel conditions, and equalization techniques on the received signal and constellation diagram.</p>
            <div class="controls">
                <div class="control-group">
                    <label for="modulationType">Modulation Type:</label>
                    <select id="modulationType">
                        <option value="qpsk">QPSK</option>
                        <option value="16qam">16-QAM</option>
                        <option value="64qam">64-QAM</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="channelType">Channel Type:</label>
                    <select id="channelType">
                        <option value="awgn">AWGN</option>
                        <option value="rayleigh">Rayleigh Fading</option>
                        <option value="multipath">Multipath</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="equalizerType">Equalizer Type:</label>
                    <select id="equalizerType">
                        <option value="none">None</option>
                        <option value="zero-forcing">Zero-Forcing</option>
                        <option value="mmse">MMSE</option>
                    </select>
                </div>
                <button id="runSimulationBtn">Run Simulation</button>
            </div>

            <h3>Transmitted Signal</h3>
            <div class="chart-container">
                <canvas id="txSignalChart"></canvas>
            </div>

            <h3>Received Signal (After Channel & Equalization)</h3>
            <div class="chart-container">
                <canvas id="rxSignalChart"></canvas>
            </div>

            <h3>Constellation Diagram</h3>
            <div class="chart-container">
                <canvas id="constellationChart"></canvas>
            </div>

            <div class="metrics">
                <div class="metric-item">
                    Bit Error Rate (BER): <strong id="berValue">N/A</strong>
                </div>
                <div class="metric-item">
                    Symbol Error Rate (SER): <strong id="serValue">N/A</strong>
                </div>
                <div class="metric-item">
                    Simulated SNR: <strong id="simSnrValue">N/A</strong>
                </div>
            </div>
            <p>The constellation diagram visually represents the received symbols in the complex plane. Ideally, they should cluster tightly around the reference points (small black circles). Noise, interference, and uncompensated channel effects cause them to spread out, leading to errors.</p>
        </section>

        <footer>
            <p style="text-align: center; font-size: 0.9em; color: #64748b;">
                Built as an interactive demonstration. Simplified models are used for educational purposes.
            </p>
        </footer>
    </div>

    <script>
        // --- Global Chart Variables (Initialize them to null here) ---
        let subcarrierChart, orthogonalityChart, cyclicPrefixChart, ofdmSystemChart;
        let paprChart, foffsetChart, timingChart, channelChart;
        let txSignalChart, rxSignalChart, constellationChart;

        // Complex Number Class (As implied by your code)
        class Complex {
            constructor(real, imag) {
                this.real = real;
                this.imag = imag;
            }

            add(other) {
                return new Complex(this.real + other.real, this.imag + other.imag);
            }

            mult(other) {
                return new Complex(this.real * other.real - this.imag * other.imag,
                                   this.real * other.imag + this.imag * other.real);
            }

            magnitude() {
                return Math.sqrt(this.real * this.real + this.imag * this.imag);
            }
        }

        // --- Missing or Assumed Helper Functions ---

        // Placeholder for IFFT (needs a proper FFT library or implementation)
        // This is a simplified, non-functional placeholder.
        // A real IFFT would be a numerical algorithm (like Cooley-Tukey).
        function ifft(freqDomainSymbols) {
            const N = freqDomainSymbols.length;
            const timeDomainSignal = [];

            // This is NOT a real IFFT. It's a dummy for demonstration.
            // A proper implementation would involve complex exponentials and summation.
            for (let n = 0; n < N; n++) {
                let realSum = 0;
                let imagSum = 0;
                for (let k = 0; k < N; k++) {
                    const symbol = freqDomainSymbols[k] || new Complex(0,0);
                    const angle = 2 * Math.PI * k * n / N;
                    realSum += symbol.real * Math.cos(angle) + symbol.imag * Math.sin(angle);
                    imagSum += symbol.imag * Math.cos(angle) - symbol.real * Math.sin(angle);
                }
                timeDomainSignal.push(new Complex(realSum / N, imagSum / N)); // Divide by N for IFFT
            }
            return timeDomainSignal;
        }

        // This is the CRUCIAL missing function from your snippet
        function generateOfdmSignal(numSubcarriers, cpRatio) {
            const numDataSubcarriers = numSubcarriers; // Simplified: assuming all are data subcarriers
            const symbolLength = numSubcarriers; // Length of IFFT output
            const cpLength = Math.round(symbolLength * cpRatio);
            const totalSymbolLength = symbolLength + cpLength;

            // 1. Generate random complex symbols (e.g., QPSK, 16QAM, etc. - simplified for this example)
            const symbols = [];
            for (let i = 0; i < numDataSubcarriers; i++) {
                // Simplified: Just random complex numbers for demonstration
                // In a real system, these would be modulated data symbols
                symbols.push(new Complex(Math.random() * 2 - 1, Math.random() * 2 - 1));
            }

            // Pad with zeros for IFFT if numSubcarriers is not a power of 2
            // Or assume numSubcarriers is always a power of 2 for IFFT
            const paddedSymbols = [...symbols];
            while (paddedSymbols.length < symbolLength) {
                paddedSymbols.push(new Complex(0, 0));
            }

            // 2. Perform IFFT to get time-domain signal
            const timeDomainData = ifft(paddedSymbols);

            // 3. Add Cyclic Prefix
            const cp = timeDomainData.slice(symbolLength - cpLength, symbolLength);
            const timeSignal = [...cp, ...timeDomainData]; // CP + Data

            return { symbols: symbols, timeSignal: timeSignal };
        }

        // --- Chart Initialization Function ---
        function initializeCharts() {
            // Subcarrier Chart
            subcarrierChart = new Chart(document.getElementById('subcarrierChart').getContext('2d'), {
                type: 'line',
                data: {
                    labels: Array.from({length: 100}, (_, i) => i),
                    datasets: [
                        {
                            label: 'Subcarrier 1',
                            borderColor: 'rgb(75, 192, 192)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        },
                        {
                            label: 'Subcarrier 2',
                            borderColor: 'rgb(255, 99, 132)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        },
                        {
                            label: 'Subcarrier 3',
                            borderColor: 'rgb(54, 162, 235)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Frequency' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        },
                        y: {
                            title: { display: true, text: 'Amplitude' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        }
                    },
                    plugins: { legend: { display: true } }
                }
            });

            // Orthogonality Chart
            orthogonalityChart = new Chart(document.getElementById('orthogonalityChart').getContext('2d'), {
                type: 'line',
                data: {
                    labels: Array.from({length: 100}, (_, i) => i),
                    datasets: [
                        {
                            label: 'Subcarrier F1',
                            borderColor: 'rgb(75, 192, 192)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        },
                        {
                            label: 'Subcarrier F2',
                            borderColor: 'rgb(255, 99, 132)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        },
                        {
                            label: 'Subcarrier F3',
                            borderColor: 'rgb(54, 162, 235)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Time' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        },
                        y: {
                            title: { display: true, text: 'Amplitude' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        }
                    },
                    plugins: { legend: { display: true } }
                }
            });

            // Cyclic Prefix Chart
            cyclicPrefixChart = new Chart(document.getElementById('cyclicPrefixChart').getContext('2d'), {
                type: 'line',
                data: {
                    labels: Array.from({length: 100}, (_, i) => i),
                    datasets: [
                        {
                            label: 'OFDM Symbol',
                            borderColor: 'rgb(75, 192, 192)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        },
                        {
                            label: 'Cyclic Prefix',
                            borderColor: 'rgb(255, 99, 132)',
                            borderDash: [5, 5],
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Time Sample' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        },
                        y: {
                            title: { display: true, text: 'Amplitude' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        }
                    },
                    plugins: { legend: { display: true } }
                }
            });

            // OFDM System Chart (Tx vs Rx)
            ofdmSystemChart = new Chart(document.getElementById('ofdmSystemChart').getContext('2d'), {
                type: 'line',
                data: {
                    labels: Array.from({length: 100}, (_, i) => i),
                    datasets: [
                        {
                            label: 'Transmitted Signal (Real)',
                            borderColor: 'rgb(75, 192, 192)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        },
                        {
                            label: 'Received Signal (Real)',
                            borderColor: 'rgb(255, 99, 132)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Time Sample' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        },
                        y: {
                            title: { display: true, text: 'Amplitude' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        }
                    },
                    plugins: { legend: { display: true } }
                }
            });

            // PAPR Chart
            paprChart = new Chart(document.getElementById('paprChart').getContext('2d'), {
                type: 'line',
                data: {
                    labels: Array.from({length: 100}, (_, i) => i),
                    datasets: [
                        {
                            label: 'Instantaneous Power (dB)',
                            borderColor: 'rgb(75, 192, 192)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        },
                        {
                            label: 'Average Power (dB)',
                            borderColor: 'rgb(255, 99, 132)',
                            borderDash: [5, 5],
                            tension: 0,
                            pointRadius: 0,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Time Sample' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        },
                        y: {
                            title: { display: true, text: 'Power (dB)' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        }
                    },
                    plugins: { legend: { display: true } }
                }
            });

            // Frequency Offset Chart
            foffsetChart = new Chart(document.getElementById('foffsetChart').getContext('2d'), {
                type: 'line',
                data: {
                    labels: Array.from({length: 100}, (_, i) => i),
                    datasets: [
                        {
                            label: 'Subcarriers with Offset',
                            borderColor: 'rgb(255, 99, 132)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        },
                        {
                            label: 'Original Subcarriers',
                            borderColor: 'rgb(75, 192, 192)',
                            borderDash: [5, 5],
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Frequency' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        },
                        y: {
                            title: { display: true, text: 'Amplitude' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        }
                    },
                    plugins: { legend: { display: true } }
                }
            });

            // Timing Offset Chart
            timingChart = new Chart(document.getElementById('timingChart').getContext('2d'), {
                type: 'line',
                data: {
                    labels: Array.from({length: 100}, (_, i) => i),
                    datasets: [
                        {
                            label: 'Symbol with Offset',
                            borderColor: 'rgb(255, 99, 132)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        },
                        {
                            label: 'Original Symbol',
                            borderColor: 'rgb(75, 192, 192)',
                            borderDash: [5, 5],
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Time Sample' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        },
                        y: {
                            title: { display: true, text: 'Amplitude' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        }
                    },
                    plugins: { legend: { display: true } }
                }
            });

            // Channel Chart
            channelChart = new Chart(document.getElementById('channelChart').getContext('2d'), {
                type: 'line',
                data: {
                    labels: Array.from({length: 64}, (_, i) => i),
                    datasets: [
                        {
                            label: 'Actual Channel (dB)',
                            borderColor: 'rgb(75, 192, 192)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        },
                        {
                            label: 'Channel Estimate (dB)',
                            borderColor: 'rgb(255, 99, 132)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Subcarrier Index' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        },
                        y: {
                            title: { display: true, text: 'Magnitude (dB)' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        }
                    },
                    plugins: { legend: { display: true } }
                }
            });

            // Transmitted Signal Chart (Main Simulation)
            txSignalChart = new Chart(document.getElementById('txSignalChart').getContext('2d'), {
                type: 'line',
                data: {
                    labels: Array.from({length: 100}, (_, i) => i),
                    datasets: [
                        {
                            label: 'Real Part',
                            borderColor: 'rgb(75, 192, 192)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        },
                        {
                            label: 'Imaginary Part',
                            borderColor: 'rgb(255, 99, 132)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Time Sample' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        },
                        y: {
                            title: { display: true, text: 'Amplitude' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        }
                    },
                    plugins: { legend: { display: true } }
                }
            });

            // Received Signal Chart (Main Simulation)
            rxSignalChart = new Chart(document.getElementById('rxSignalChart').getContext('2d'), {
                type: 'line',
                data: {
                    labels: Array.from({length: 100}, (_, i) => i),
                    datasets: [
                        {
                            label: 'Real Part',
                            borderColor: 'rgb(75, 192, 192)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        },
                        {
                            label: 'Imaginary Part',
                            borderColor: 'rgb(255, 99, 132)',
                            tension: 0.4,
                            pointRadius: 0,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Time Sample' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        },
                        y: {
                            title: { display: true, text: 'Amplitude' },
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        }
                    },
                    plugins: { legend: { display: true } }
                }
            });

            // Constellation Chart (Main Simulation)
            constellationChart = new Chart(document.getElementById('constellationChart').getContext('2d'), {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Received Symbols',
                            data: [],
                            backgroundColor: 'rgba(75, 192, 192, 0.6)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            pointRadius: 5
                        },
                        {
                            label: 'Reference Points',
                            data: [],
                            backgroundColor: 'black',
                            pointRadius: 7,
                            pointStyle: 'crossRot', // 'circle', 'triangle', 'rect', 'cross', 'star', 'line', 'dash'
                            borderColor: 'black'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: { display: true, text: 'Real' },
                            min: -1.5, // Adjust as needed for constellation scaling
                            max: 1.5,
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: { display: true, text: 'Imaginary' },
                            min: -1.5, // Adjust as needed
                            max: 1.5,
                            grid: { color: 'rgba(200, 200, 200, 0.2)' }
                        }
                    },
                    plugins: { legend: { display: true } }
                }
            });
        }


        // --- Your provided JavaScript functions go here ---

        function updateSubcarrierChart(isOfdm) {
            const labels = Array.from({length: 100}, (_, i) => i);
            let dataset1Data = [];
            let dataset2Data = [];
            let dataset3Data = [];

            if (isOfdm) {
                // OFDM: Overlapping orthogonal sinc functions
                const N = 100; // Number of points
                const fc1 = 20; // Center frequency for subcarrier 1
                const fc2 = 40; // Center frequency for subcarrier 2
                const fc3 = 60; // Center frequency for subcarrier 3

                dataset1Data = labels.map(f => {
                    const x = (f - fc1);
                    return x === 0 ? 1 : Math.sin(Math.PI * x / (N/20)) / (Math.PI * x / (N/20)); // Sinc function
                });
                dataset2Data = labels.map(f => {
                    const x = (f - fc2);
                    return x === 0 ? 1 : Math.sin(Math.PI * x / (N/20)) / (Math.PI * x / (N/20));
                });
                dataset3Data = labels.map(f => {
                    const x = (f - fc3);
                    return x === 0 ? 1 : Math.sin(Math.PI * x / (N/20)) / (Math.PI * x / (N/20));
                });

                // Scale for better visualization
                const maxVal = Math.max(...dataset1Data.map(Math.abs), ...dataset2Data.map(Math.abs), ...dataset3Data.map(Math.abs));
                dataset1Data = dataset1Data.map(d => d / maxVal * 10);
                dataset2Data = dataset2Data.map(d => d / maxVal * 10);
                dataset3Data = dataset3Data.map(d => d / maxVal * 10);

            } else {
                // Traditional FDM: Separate frequency bands
                const bandWidth = 15;
                dataset1Data = labels.map(i => i >= 10 && i < 10 + bandWidth ? 10 : 0);
                dataset2Data = labels.map(i => i >= 40 && i < 40 + bandWidth ? 10 : 0);
                dataset3Data = labels.map(i => i >= 70 && i < 70 + bandWidth ? 10 : 0);
            }

            subcarrierChart.data.datasets[0].data = dataset1Data;
            subcarrierChart.data.datasets[1].data = dataset2Data;
            subcarrierChart.data.datasets[2].data = dataset3Data;
            subcarrierChart.update();
        }

        function updateOrthogonalityChart(showMultiple) {
            const labels = Array.from({length: 100}, (_, i) => i);
            const freq1 = 2; // Frequency for subcarrier 1
            const freq2 = 4; // Frequency for subcarrier 2
            const freq3 = 6; // Frequency for subcarrier 3 (orthogonal)

            const dataset1Data = labels.map(t => Math.sin(2 * Math.PI * freq1 * t / 100) * 10);

            if (showMultiple) {
                const dataset2Data = labels.map(t => Math.sin(2 * Math.PI * freq2 * t / 100) * 10);
                const dataset3Data = labels.map(t => Math.sin(2 * Math.PI * freq3 * t / 100) * 10);
                orthogonalityChart.data.datasets[1].data = dataset2Data;
                orthogonalityChart.data.datasets[2].data = dataset3Data;
            } else {
                orthogonalityChart.data.datasets[1].data = []; // Clear other datasets
                orthogonalityChart.data.datasets[2].data = [];
            }

            orthogonalityChart.data.datasets[0].data = dataset1Data;
            orthogonalityChart.update();
        }

        function updateCyclicPrefixChart(withCp) {
            const labels = Array.from({length: 100}, (_, i) => i);
            const symbolLength = 60; // Length of the core OFDM symbol
            const cpLength = 10;     // Length of the cyclic prefix

            // Generate a simple sinusoidal symbol
            const coreSymbol = labels.slice(0, symbolLength).map(x => 20 * Math.sin(2 * Math.PI * x / 20));

            let fullSymbol = [];
            let cpVisualization = [];

            if (withCp) {
                // Take the last 'cpLength' samples and put them at the beginning
                const cp = coreSymbol.slice(symbolLength - cpLength, symbolLength);
                fullSymbol = [...cp, ...coreSymbol];

                // Create a dataset for visualizing the CP part
                cpVisualization = Array(100).fill(null);
                for (let i = 0; i < cpLength; i++) {
                    cpVisualization[i] = fullSymbol[i];
                }
            } else {
                fullSymbol = coreSymbol;
            }

            // Pad with zeros if the symbol is shorter than 100 samples for the chart
            while (fullSymbol.length < 100) {
                fullSymbol.push(0);
            }

            cyclicPrefixChart.data.datasets[0].data = fullSymbol;
            cyclicPrefixChart.data.datasets[1].data = cpVisualization; // CP part
            cyclicPrefixChart.update();
        }

        function updateOfdmSystemChart(numSubcarriersStr, cpRatioStr, snrStr) {
            const numSubcarriers = parseInt(numSubcarriersStr);
            const cpRatio = parseFloat(cpRatioStr);
            const snr = parseFloat(snrStr); // SNR in dB

            // Convert SNR from dB to linear scale for noise calculation
            const snrLinear = Math.pow(10, snr / 10);
            // Simplified noise level calculation. Adjust this for realistic SNR.
            // A common way: noise power = signal power / snrLinear.
            // For visualization, we just need a magnitude.
            const noiseLevel = 1 / Math.sqrt(snrLinear) * 0.5; // Heuristic for visual effect

            // Generate a dummy OFDM symbol for visualization (not a real one from IFFT)
            const sampleLength = 100;
            const ofdmSymbol = Array.from({length: sampleLength}, (_, i) => {
                // Create a sample complex value
                const sample = new Complex(
                    Math.sin(2 * Math.PI * i / (sampleLength / (numSubcarriers / 4))), // Some fundamental freq
                    Math.cos(2 * Math.PI * i / (sampleLength / (numSubcarriers / 4))) // Some fundamental freq
                );
                // Introduce some "complexity" from multiple subcarriers
                sample.real += 0.5 * Math.sin(2 * Math.PI * i / (sampleLength / (numSubcarriers / 2)));
                sample.imag += 0.5 * Math.cos(2 * Math.PI * i / (sampleLength / (numSubcarriers / 2)));
                return sample;
            });

            // Simulate noise and channel effect
            const rxSignal = ofdmSymbol.map(sample => {
                return {
                    real: sample.real + noiseLevel * (Math.random() - 0.5),
                    imag: sample.imag + noiseLevel * (Math.random() - 0.5)
                };
            });

            // Update chart with first 100 samples
            const txData = ofdmSymbol.slice(0, 100).map(s => s.real);
            const rxData = rxSignal.slice(0, 100).map(s => s.real);

            ofdmSystemChart.data.datasets[0].data = txData;
            ofdmSystemChart.data.datasets[1].data = rxData;
            ofdmSystemChart.update();
        }

        function updatePaprChart() {
            // Generate a signal with high PAPR
            const labels = Array.from({length: 100}, (_, i) => i);
            const signal = labels.map(x => {
                const sum = Array.from({length: 8}, (_, k) =>
                    Math.cos(2 * Math.PI * x * (k + 1) / 100)
                ).reduce((a, b) => a + b, 0);
                // Add a small constant to avoid log10(0) for visualization
                return 20 * Math.log10(Math.abs(sum) + 0.001);
            });

            const avgPower = 10; // Average power in dB

            paprChart.data.datasets[0].data = signal;
            paprChart.data.datasets[1].data = Array(100).fill(avgPower);
            paprChart.update();
        }

        function updateFoffsetChart() {
            const labels = Array.from({length: 100}, (_, i) => i);

            // Original subcarriers (3 orthogonal sinc functions)
            const original = labels.map(x => {
                const center1 = 20;
                const center2 = 50;
                const center3 = 80;
                // Sinc function approximation for frequency domain
                const sinc = (val, center) => {
                    const arg = Math.PI * (val - center);
                    return arg === 0 ? 1 : Math.sin(arg) / arg;
                };

                return Math.abs(sinc(x, center1)) * 50 +
                       Math.abs(sinc(x, center2)) * 50 +
                       Math.abs(sinc(x, center3)) * 50;
            });

            // Subcarriers with frequency offset
            const offset = 2; // Introduce a frequency offset
            const withOffset = labels.map(x => {
                const center1 = 20 + offset;
                const center2 = 50 + offset;
                const center3 = 80 + offset;
                const sinc = (val, center) => {
                    const arg = Math.PI * (val - center);
                    return arg === 0 ? 1 : Math.sin(arg) / arg;
                };

                return Math.abs(sinc(x, center1)) * 50 +
                       Math.abs(sinc(x, center2)) * 50 +
                       Math.abs(sinc(x, center3)) * 50;
            });

            foffsetChart.data.datasets[0].data = withOffset;
            foffsetChart.data.datasets[1].data = original;
            foffsetChart.update();
        }

        function updateTimingChart() {
            const labels = Array.from({length: 100}, (_, i) => i);

            // Original OFDM symbol (simplified as a modulated pulse)
            const original = labels.map(x => {
                if (x < 20 || x >= 80) return 0; // Define a symbol window
                return 30 * Math.sin(2 * Math.PI * (x - 20) / 30) *
                       Math.sin(2 * Math.PI * (x - 20) / 15); // Multiple frequencies for complex shape
            });

            // With timing offset
            const offset = 10; // Introduce a timing offset
            const withOffset = labels.map(x => {
                const pos = x - offset; // Shift the original symbol
                if (pos < 20 || pos >= 80) return 0;
                return 30 * Math.sin(2 * Math.PI * (pos - 20) / 30) *
                       Math.sin(2 * Math.PI * (pos - 20) / 15);
            });

            timingChart.data.datasets[0].data = withOffset;
            timingChart.data.datasets[1].data = original;
            timingChart.update();
        }

        function updateChannelChart() {
            const labels = Array.from({length: 64}, (_, i) => i);

            // Channel frequency response (random fading)
            const channel = labels.map(i => {
                const fade = 0.5 + 0.5 * Math.random(); // Random fade factor
                // Small constant to prevent log10(0)
                return 20 * Math.log10(fade + 0.001); // Convert to dB
            });

            // Channel estimate (with some error)
            const estimate = channel.map(h => {
                const error = 2 * (Math.random() - 0.5); // Random error in dB
                return h + error;
            });

            channelChart.data.datasets[0].data = channel;
            channelChart.data.datasets[1].data = estimate;
            channelChart.update();
        }

        function runSimulation() {
            const modulationType = document.getElementById('modulationType').value;
            const channelType = document.getElementById('channelType').value;
            const equalizerType = document.getElementById('equalizerType').value;

            // Generate transmitted signal
            // Assuming 64 subcarriers for full simulation as a common value
            const { symbols, timeSignal } = generateOfdmSignal(64, 0.1);

            // Update transmitted signal plot
            const txReal = timeSignal.map(s => s.real);
            const txImag = timeSignal.map(s => s.imag);
            txSignalChart.data.datasets[0].data = txReal.slice(0,100); // Limit to first 100 for display
            txSignalChart.data.datasets[1].data = txImag.slice(0,100);
            txSignalChart.update();

            // Simulate channel effects
            let rxSymbols = symbols.map(symbol => {
                let h = new Complex(1, 0); // Channel coefficient (complex for more realistic simulation)
                let noise = new Complex(0, 0);

                switch(channelType) {
                    case 'awgn':
                        noise = new Complex(0.1 * (Math.random() - 0.5), 0.1 * (Math.random() - 0.5));
                        break;
                    case 'rayleigh':
                        // Rayleigh fading affects magnitude. Angle for phase distortion.
                        const magnitude = Math.sqrt(-2 * Math.log(1 - Math.random()));
                        const phase = 2 * Math.PI * Math.random();
                        h = new Complex(magnitude * Math.cos(phase), magnitude * Math.sin(phase));
                        noise = new Complex(0.1 * (Math.random() - 0.5), 0.1 * (Math.random() - 0.5));
                        break;
                    case 'multipath':
                        // Simplified multipath: fixed attenuation and some random phase/attenuation
                        const mpMagnitude = 0.8 + 0.4 * Math.random();
                        const mpPhase = 0.2 * Math.PI * (Math.random() - 0.5); // Small phase shift
                        h = new Complex(mpMagnitude * Math.cos(mpPhase), mpMagnitude * Math.sin(mpPhase));
                        noise = new Complex(0.2 * (Math.random() - 0.5), 0.2 * (Math.random() - 0.5));
                        break;
                }

                // Apply channel: Y = H * X + N
                const receivedWithoutNoise = h.mult(symbol);
                return receivedWithoutNoise.add(noise);
            });

            // Apply equalization
            if (equalizerType !== 'none') {
                rxSymbols = rxSymbols.map(symbol => {
                    let hEst = new Complex(0.8, 0.1); // Simplified channel estimate for equalization demo

                    switch(equalizerType) {
                        case 'zero-forcing':
                            // ZF: Y_eq = Y / H_est (divide by complex conjugate)
                            const hEstMagSq = hEst.real * hEst.real + hEst.imag * hEst.imag;
                            if (hEstMagSq === 0) return new Complex(0,0); // Avoid division by zero
                            return new Complex(
                                (symbol.real * hEst.real + symbol.imag * hEst.imag) / hEstMagSq,
                                (symbol.imag * hEst.real - symbol.real * hEst.imag) / hEstMagSq
                            );
                        case 'mmse':
                            // MMSE: H_est* / (|H_est|^2 + N0/Es) * Y
                            // Simplified N0/Es (noise-to-signal ratio) as a constant 0.1 for demo
                            const snrInverse = 0.1;
                            const denominator = hEst.real * hEst.real + hEst.imag * hEst.imag + snrInverse;
                            if (denominator === 0) return new Complex(0,0);
                            const hEstConj = new Complex(hEst.real, -hEst.imag);
                            const equalizerGain = hEstConj.mult(new Complex(1/denominator, 0));
                            return symbol.mult(equalizerGain);
                        default:
                            return symbol;
                    }
                });
            }

            // Generate received time signal (simplified for plot, not from IFFT of rxSymbols)
            const rxTimeSignal = timeSignal.map(sample => {
                return {
                    real: sample.real + 0.1 * (Math.random() - 0.5),
                    imag: sample.imag + 0.1 * (Math.random() - 0.5)
                };
            });

            // Update received signal plot
            const rxReal = rxTimeSignal.map(s => s.real);
            const rxImag = rxTimeSignal.map(s => s.imag);
            rxSignalChart.data.datasets[0].data = rxReal.slice(0,100);
            rxSignalChart.data.datasets[1].data = rxImag.slice(0,100);
            rxSignalChart.update();

            // Update constellation diagram
            constellationChart.data.datasets[0].data = rxSymbols.map(s => ({
                x: s.real,
                y: s.imag
            }));

            // Reference constellation points
            let refPoints = [];
            // Scale reference points to a common magnitude for plotting.
            // For QPSK/16QAM/64QAM, the average power can be normalized.
            // A simple approach is to ensure the maximum magnitude of a constellation point is 1.
            const qpskScale = 1 / Math.sqrt(2);
            const qam16Scale = 1 / Math.sqrt(10); // For [-3,-1,1,3] values, average power is (9+1+1+9)/4 = 5, sqrt(5) for amplitude. For unit power, it's 1/sqrt(10)
            const qam64Scale = 1 / Math.sqrt(42); // For [-7,-5,-3,-1,1,3,5,7] values, avg power is 42/4. sqrt(42) for amplitude

            switch(modulationType) {
                case 'qpsk':
                    refPoints = [
                        {x: 1 * qpskScale, y: 1 * qpskScale},
                        {x: -1 * qpskScale, y: 1 * qpskScale},
                        {x: -1 * qpskScale, y: -1 * qpskScale},
                        {x: 1 * qpskScale, y: -1 * qpskScale}
                    ];
                    break;
                case '16qam':
                    for (let i = -3; i <= 3; i += 2) {
                        for (let j = -3; j <= 3; j += 2) {
                            refPoints.push({x: i * qam16Scale, y: j * qam16Scale});
                        }
                    }
                    break;
                case '64qam':
                    for (let i = -7; i <= 7; i += 2) {
                        for (let j = -7; j <= 7; j += 2) {
                            refPoints.push({x: i * qam64Scale, y: j * qam64Scale});
                        }
                    }
                    break;
            }

            constellationChart.data.datasets[1].data = refPoints;
            constellationChart.update();

            // Calculate error rates (simplified)
            let errorCount = 0;
            const threshold = 0.3; // Distance threshold for error detection

            rxSymbols.forEach(rxSym => {
                let minDistance = Infinity;
                let closestRef = null;

                refPoints.forEach(ref => {
                    const dist = Math.sqrt(
                        Math.pow(rxSym.real - ref.x, 2) +
                        Math.pow(rxSym.imag - ref.y, 2)
                    );
                    if (dist < minDistance) {
                        minDistance = dist;
                        closestRef = ref;
                    }
                });

                if (minDistance > threshold) { // If received symbol is too far from any reference
                    errorCount++;
                }
            });

            const ser = errorCount / rxSymbols.length;
            let ber;
            switch(modulationType) {
                case 'qpsk':
                    ber = ser / 2; // 2 bits per symbol
                    break;
                case '16qam':
                    ber = ser / 4; // 4 bits per symbol
                    break;
                case '64qam':
                    ber = ser / 6; // 6 bits per symbol
                    break;
                default:
                    ber = ser;
            }

            // Update metrics
            document.getElementById('berValue').textContent = ber.toFixed(4);
            document.getElementById('serValue').textContent = ser.toFixed(4);
            document.getElementById('simSnrValue').textContent = `${snr} dB`; // Display selected SNR
        }

        // --- Event Handlers ---
        function setupEventHandlers() {
            // Subcarrier visualization buttons
            document.getElementById('showTraditionalFdm').addEventListener('click', () => {
                updateSubcarrierChart(false);
            });
            document.getElementById('showOfdm').addEventListener('click', () => {
                updateSubcarrierChart(true);
            });

            // Orthogonality visualization buttons
            document.getElementById('showSingleSubcarrier').addEventListener('click', () => {
                updateOrthogonalityChart(false);
            });
            document.getElementById('showMultipleSubcarriers').addEventListener('click', () => {
                updateOrthogonalityChart(true);
            });

            // Cyclic prefix visualization buttons
            document.getElementById('showWithoutCp').addEventListener('click', () => {
                updateCyclicPrefixChart(false);
            });
            document.getElementById('showWithCp').addEventListener('click', () => {
                updateCyclicPrefixChart(true);
            });

            // OFDM system parameters
            const numSubcarriersSlider = document.getElementById('numSubcarriers');
            const numSubcarriersValue = document.getElementById('numSubcarriersValue');
            const cpRatioSlider = document.getElementById('cpRatio');
            const cpRatioValue = document.getElementById('cpRatioValue');
            const snrSlider = document.getElementById('snr');
            const snrValue = document.getElementById('snrValue');

            numSubcarriersSlider.addEventListener('input', () => {
                const value = numSubcarriersSlider.value;
                numSubcarriersValue.textContent = `${value} subcarriers`;
                updateOfdmSystemChart(value, cpRatioSlider.value, snrSlider.value);
            });

            cpRatioSlider.addEventListener('input', () => {
                const value = cpRatioSlider.value;
                cpRatioValue.textContent = `${Math.round(value * 100)}%`;
                updateOfdmSystemChart(numSubcarriersSlider.value, value, snrSlider.value);
            });

            snrSlider.addEventListener('input', () => {
                const value = snrSlider.value;
                snrValue.textContent = `${value} dB`;
                updateOfdmSystemChart(numSubcarriersSlider.value, cpRatioSlider.value, value);
            });

            // Transmit button
            document.getElementById('transmitBtn').addEventListener('click', () => {
                updateOfdmSystemChart(numSubcarriersSlider.value, cpRatioSlider.value, snrSlider.value);
            });

            // Tab buttons
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');

                    // Remove active class from all buttons and contents
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));

                    // Add active class to clicked button and corresponding content
                    this.classList.add('active');
                    document.getElementById(`${tabId}-tab`).classList.add('active');

                    // Update the chart for the active tab
                    switch(tabId) {
                        case 'pap':
                            updatePaprChart();
                            break;
                        case 'foffset':
                            updateFoffsetChart();
                            break;
                        case 'timing':
                            updateTimingChart();
                            break;
                        case 'channel':
                            updateChannelChart();
                            break;
                    }
                });
            });

            // Simulation button
            document.getElementById('runSimulationBtn').addEventListener('click', runSimulation);

            // High contrast toggle
            document.getElementById('contrastToggle').addEventListener('click', function() {
                document.body.classList.toggle('high-contrast');

                // The inline style changes are handled by the CSS for cleaner separation
                // The provided JS had inline style changes, but it's better to manage via CSS classes.
                // Leaving the previous JS style changes commented out for reference if needed
                /*
                if (document.body.classList.contains('high-contrast')) {
                    document.body.style.backgroundColor = '#000';
                    document.body.style.color = '#fff';
                    document.querySelectorAll('section').forEach(section => {
                        section.style.backgroundColor = '#111';
                        section.style.color = '#fff';
                    });
                } else {
                    document.body.style.backgroundColor = '#f8fafc';
                    document.body.style.color = '#334155';
                    document.querySelectorAll('section').forEach(section => {
                        section.style.backgroundColor = '#fff';
                        section.style.color = '#334155';
                    });
                }
                */
            });
        }

        // --- Initialize Everything ---
        document.addEventListener('DOMContentLoaded', function() {
            initializeCharts();
            setupEventHandlers();

            // Initialize with default visualizations
            updateSubcarrierChart(true);
            updateOrthogonalityChart(true);
            updateCyclicPrefixChart(true);
            updateOfdmSystemChart(16, 0.1, 20); // Initial values for system chart
            updatePaprChart();
            updateFoffsetChart();
            updateTimingChart();
            updateChannelChart();

            // Run initial simulation
            runSimulation();
        });
    </script>
</body>
</html>
